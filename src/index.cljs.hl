(page "index.html"
      (:require-macros [cljs.core.async.macros :refer [go go-loop]])
      (:require [cljs.core.async :refer [put! chan <! >! timeout close!]]
                [goog.labs.format.csv :as csv]
                [clojure.string :as string]
                [cljs-idxdb.core :as idx]))

;; channel-based architecture credits https://mrmcc3.github.io/post/csv-with-clojurescript/

(def db (atom nil))
(def store-txs "transactions")
(def store-tags "tags")

(idx/create-db "fin" 1
               #(->
                 (do

                   (idx/delete-and-create-store % store-txs {:autoIncrement true})
                   (idx/delete-and-create-store % store-tags {:autoIncrement true})))
               #(reset! db %))

;;(idx/create-index "dateIdx" "date" {:unique false})
;;(idx/create-index "descriptionIdx" "description" {:unique false})
;;(idx/create-index "amountIdx" "amount" {:unique false})
(def first-file
  (map (fn [e]
         (let [target (.-currentTarget e)
               file (-> target .-files (aget 0))]
           (set! (.-value target) "")
           file))))

(def extract-result
  (map #(-> % .-target .-result csv/parse js->clj)))

(def upload-reqs (chan 1 first-file))
(def file-reads (chan 1 extract-result))

(defn put-upload [e]
  (put! upload-reqs e))

;; a loop to write to file-reads
(go-loop []
  (let [reader (js/FileReader.)
        file (<! upload-reqs)]
    (print (str "filename" (.-name file)))
    (set! (.-onload reader) #(put! file-reads %))
    (.readAsText reader file)
    (recur)))

;; a loop to read from file-reads
(go-loop []
  (let [data (<! file-reads)
        [header & rest] data]
    ;(println (str "header " header))
    (doseq [datum rest]
      (idx/add-item @db store-txs {:date (get datum 0) :description (get datum 1) :amount (get datum 2)} #(println (str "storing " datum)))))
  (recur))

(def transactions (cell #{}))

(defelem transaction-list [{:keys [from sorted-by] :or {sorted-by identity}}]
  (loop-tpl :bindings [transaction (cell= (sort-by sorted-by from))]
            (li (span (cell= (str transaction)))
                (button :click #(swap! from disj @transaction) "Delete"))))

(defn render [{:keys [description amount date] :as tx}]
  (str date " " description " " amount))
(defn fetch [txs]
  (doseq [tx txs]
    (swap! transactions conj (render tx))
    ))
(defn fetch-and-render []
  (idx/get-all @db store-txs fetch))

(html
  (head
    (link :href "app.css" :rel "stylesheet" :type "text/css"))
  (body
   (h1 "Fin")
    (p "Choose a CSV file")
    (input :type "file" :accept ".csv" :change put-upload)
    (button :click fetch-and-render "Read")
    (ul (transaction-list :from transactions ))))



